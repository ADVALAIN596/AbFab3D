/*****************************************************************************
 *                        Shapeways, Inc Copyright (c) 2011
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package abfab3d.transforms;

import java.util.Vector;

import javax.vecmath.Matrix3d;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector4d;
import javax.vecmath.Matrix4d;
import javax.vecmath.AxisAngle4d;

import abfab3d.util.Vec;
import abfab3d.util.Initializable;
import abfab3d.util.Symmetry;
import abfab3d.util.ReflectionGroup;
import abfab3d.util.VecTransform;
import abfab3d.util.DataSource;
import abfab3d.util.Units;

import net.jafama.FastMath;

import static abfab3d.util.Output.printf;
import static abfab3d.util.Symmetry.getReflection;
import static abfab3d.util.Symmetry.toFundamentalDomain;



/**
   makes transformations for symmetry groups generated by reflections
*/
public class ReflectionSymmetry  implements VecTransform, Initializable  {
    
    static final boolean DEBUG = false;
    static int debugCount = 1000;
    
    ReflectionGroup group;
    double riemannSphereRadius;
    int m_maxCount = 100;

    public ReflectionSymmetry(){            
        
    }
    
    public ReflectionSymmetry(ReflectionGroup.SPlane fundamentalDomain[]){            

        setGroup(fundamentalDomain);

    }

    public void setGroup(ReflectionGroup group){
        this.group = group;
    }

    /**
       sets the reflection group via it's fundamental domain
     */
    public void setGroup(ReflectionGroup.SPlane fundamentalDomain[]){

        this.group = new ReflectionGroup(fundamentalDomain);

    }

    public void setMaxCount(int count){
        this.m_maxCount  = count;
    }
    
    public void setRiemannSphereRadius(double value){
        this.riemannSphereRadius = value;
    }
    
    public int initialize(){
        
        if(group == null){               
            // init to simple one generator group 
            group = new ReflectionGroup(new ReflectionGroup.SPlane[]{new ReflectionGroup.Plane(new Vector3d(1,0,0),0)});
        }
        
        group.setRiemannSphereRadius(riemannSphereRadius);
        group.setMaxIterations(m_maxCount);
        return RESULT_OK;
    }
    
    public int transform(Vec in, Vec out) {
        // direct transform is identity transform 
        out.set(in);
        // TODO we may use one specific element from the group
        return RESULT_OK;
        
    }


    public int inverse_transform(Vec in, Vec out) {

        out.set(in);

        if(DEBUG && debugCount-- > 0)
            printf("vs before: %5.3f\n", in.getScaledVoxelSize()/Units.MM);

        int res = group.toFundamentalDomain(out);

        if(DEBUG && debugCount-- > 0)
            printf("vs after: %5.3f\n", out.getScaledVoxelSize()/Units.MM);

        return res;
    }

    /**
       convenience method 
       returns half space defined by this plane. 
       plane is defined by normal pointing to positive half space 
       and distance along that normal
       distance my be positive or negative 
     */
    public static ReflectionGroup.SPlane getPlane(Vector3d normal, double distance){
        return new ReflectionGroup.Plane(normal, distance);
    }

    /**
       convenience method 
       returns spherical SPlane with given center. 
       if radius > 0 - the inside of sphere is used 
       if radius < 0 - the outside of sphere is used        
       
     */
    public static ReflectionGroup.SPlane getSphere(Vector3d center, double radius){
        return new ReflectionGroup.Sphere(center, radius);
    }

    public static DataSource getDataSource(ReflectionGroup.SPlane splane){
        if(splane instanceof ReflectionGroup.Plane){

            ReflectionGroup.Plane plane = (ReflectionGroup.Plane)splane;
            
            return new abfab3d.datasources.Plane(plane.getNormal(), plane.getDistance());
            
        } else if(splane instanceof ReflectionGroup.Sphere ){
            ReflectionGroup.Sphere sphere = (ReflectionGroup.Sphere)splane;
            return new abfab3d.datasources.Sphere(sphere.getCenter(), sphere.getRadius());            
        }
        return null;
    }
    
    public static DataSource getDataSource(ReflectionGroup.SPlane splanes[]){
        abfab3d.datasources.Intersection inter = new abfab3d.datasources.Intersection();
        for(int i = 0; i < splanes.length; i++){
            inter.add(getDataSource(splanes[i]));
        }
        return inter;
    }

} // class ReflectionSymmetry 

