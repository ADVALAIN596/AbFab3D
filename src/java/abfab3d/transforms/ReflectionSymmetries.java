/*****************************************************************************
 *                        Shapeways, Inc Copyright (c) 2011
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package abfab3d.transforms;

import javax.vecmath.Vector3d;

import abfab3d.util.ReflectionGroup;


import static java.lang.Math.sin;
import static java.lang.Math.cos;
import static java.lang.Math.sqrt;
import static java.lang.Math.PI;

/**
   assortmens of various symmetry groups generated by reflections in planes and inversions in spheres 
   
   @author Vladimir Bulatov

 */
public class ReflectionSymmetries {

    public static ReflectionGroup getTwoPlanes(double x1, double x2){
        
        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Plane(new Vector3d(-1,0,0), -x1), // right of  plane 1
            new ReflectionGroup.Plane(new Vector3d(1,0,0), x2), // left of plane 2
        };
        return new ReflectionGroup(s);

    }

    /**
       hyperbolic circular quadrilateral made by 2 orthogonal planes and 2 spheres. 
       angles of quadrilateral are (pi/2, pi/2, pi/2, alpha)
       r - radius of common sphere to which both spheres are orthogonal 
       the equator of that sphere will be place where all the tiles accumulate 
       r1 radius of one sphere 
       alpha angle between spheres
     */
    public static ReflectionGroup getQuad_1(double r, double r1, double alpha){
        double r2 = r*r/(r1*cos(alpha));
        double x1 = sqrt(r1*r1 + r*r);
        double y2 = sqrt(r2*r2 + r*r);
        
        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Plane(new Vector3d(-1,0,0), 0.), // 
            new ReflectionGroup.Plane(new Vector3d(0,-1,0), 0.), // 
            new ReflectionGroup.Sphere(new Vector3d(x1,0,0), -r1), // outside of sphere 1
            new ReflectionGroup.Sphere(new Vector3d(0,y2,0), -r2), // outside of sphere 2           
        };   
        return new ReflectionGroup(s);
        
    }

    public static ReflectionGroup getQuad_2(double r1, double r2, double x1, double alpha){

        double y2 = sqrt(r1*r1 + r2*r2 + 2*r1*r2*cos(alpha) - x1*x1);
        
        //printf("r1: %7.5f x1: %7.5f r2: %7.5f y2: %7.5f\n", r1, x1, r2, y2);

        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Plane(new Vector3d(-1,0,0), 0.), // 
            new ReflectionGroup.Plane(new Vector3d(0,-1,0), 0.), // 
            new ReflectionGroup.Sphere(new Vector3d(x1,0,0), -r1), // outside of sphere  
            new ReflectionGroup.Sphere(new Vector3d(0,y2,0), -r2), // outside of sphere              
        };   
        return new ReflectionGroup(s);
    }

    public static ReflectionGroup getTwoSpheres(double r1, double r2){
        
        if(r1 > r2) {
            double t = r2;
            r2 = r1;
            r1 = t;
        }

        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Sphere(new Vector3d(0,0,0), -r1), // outside of smaller sphere 
            new ReflectionGroup.Sphere(new Vector3d(0,0,0), r2), // inside of larger sphere  
        };
        return new ReflectionGroup(s);
    }
    
    public static ReflectionGroup getPlaneAndSphere(double x, double r){
        double n = (r > 0)? (-1) : (1);
        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Plane(new Vector3d(n,0,0), 0.), // right of yz plane
            new ReflectionGroup.Sphere(new Vector3d(x,0,0), -r), // outside of sphere  
        };
        return new ReflectionGroup(s);        
    }

    public static ReflectionGroup getIcosahedralKaleidoscope(){
        double t = (sqrt(5)+1)/2;

        Vector3d v5 = new Vector3d(1,0,t); // vertex of icosahedron 
        Vector3d v3 = new Vector3d(0,1/t,t); // vertex of dodecahedron 
        Vector3d p35 = new Vector3d(); p35.cross(v3, v5); p35.normalize();

        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Plane(new Vector3d(-1,0,0), 0.), 
            new ReflectionGroup.Plane(new Vector3d(0,-1,0), 0.), 
            //new ReflectionGroup.Plane(new Vector3d(0,0,1), 0.), 
            new ReflectionGroup.Plane(p35, 0.),
        };
        return new ReflectionGroup(s);          
        
    }

    public static ReflectionGroup getXYZ(double r, double ax,double ay, double az){
        double dx = r*cos(ax);
        double dy = r*cos(ay);
        double dz = r*cos(az);
        
        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Plane(new Vector3d(-1,0,0), 0.), // 
            new ReflectionGroup.Plane(new Vector3d(0,-1,0), 0.), // 
            new ReflectionGroup.Plane(new Vector3d(0,0,-1), 0.), // 
            new ReflectionGroup.Sphere(new Vector3d(dx, dy, dz), -r), // outside of sphere  
        };   
        return new ReflectionGroup(s);
        
    }

    /**
       two mirrows with angle between them PI/order (order >= 2);
     */
    public static ReflectionGroup getDihedralKaleidoscope(int order){

        double alpha = PI/order;        
        
        ReflectionGroup.SPlane[] s = new ReflectionGroup.SPlane[] {
            new ReflectionGroup.Plane(new Vector3d(0,-1,0), 0.),
            new ReflectionGroup.Plane(new Vector3d(-sin(alpha), cos(alpha),0), 0.),
        };   
        return new ReflectionGroup(s);
        
    }

}
